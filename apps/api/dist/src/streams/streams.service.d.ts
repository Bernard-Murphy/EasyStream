import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../prisma/prisma.service';
export declare class StreamsService {
    private readonly prisma;
    private readonly limits;
    constructor(prisma: PrismaService, config: ConfigService);
    getByUuid(uuid: string): Promise<{
        uuid: string;
        id: number;
        start_time: Date;
        end_time: Date | null;
        anon_id: string;
        anon_text_color: string;
        anon_background_color: string;
        title: string;
        description: string;
        status: import("@prisma/client").$Enums.StreamStatus;
        removed: boolean;
        fileUrls: string[];
        thumbnailUrl: string | null;
    }>;
    listLive(sort: 'viewers' | 'recent', search?: string): Promise<{
        uuid: string;
        id: number;
        start_time: Date;
        end_time: Date | null;
        anon_id: string;
        anon_text_color: string;
        anon_background_color: string;
        title: string;
        description: string;
        status: import("@prisma/client").$Enums.StreamStatus;
        removed: boolean;
        fileUrls: string[];
        thumbnailUrl: string | null;
    }[]>;
    listPast(sort: 'recent', search?: string): Promise<{
        uuid: string;
        id: number;
        start_time: Date;
        end_time: Date | null;
        anon_id: string;
        anon_text_color: string;
        anon_background_color: string;
        title: string;
        description: string;
        status: import("@prisma/client").$Enums.StreamStatus;
        removed: boolean;
        fileUrls: string[];
        thumbnailUrl: string | null;
    }[]>;
    createStream(input: {
        title: string;
        description: string;
        thumbnailUrl?: string | null;
        anon?: {
            anon_id: string;
            anon_text_color: string;
            anon_background_color: string;
        };
    }): Promise<{
        uuid: string;
        id: number;
        start_time: Date;
        end_time: Date | null;
        anon_id: string;
        anon_text_color: string;
        anon_background_color: string;
        title: string;
        description: string;
        status: import("@prisma/client").$Enums.StreamStatus;
        removed: boolean;
        fileUrls: string[];
        thumbnailUrl: string | null;
    }>;
    endStream(uuid: string): Promise<{
        uuid: string;
        id: number;
        start_time: Date;
        end_time: Date | null;
        anon_id: string;
        anon_text_color: string;
        anon_background_color: string;
        title: string;
        description: string;
        status: import("@prisma/client").$Enums.StreamStatus;
        removed: boolean;
        fileUrls: string[];
        thumbnailUrl: string | null;
    }>;
    markPast(uuid: string, fileUrls: string[]): Promise<{
        uuid: string;
        id: number;
        start_time: Date;
        end_time: Date | null;
        anon_id: string;
        anon_text_color: string;
        anon_background_color: string;
        title: string;
        description: string;
        status: import("@prisma/client").$Enums.StreamStatus;
        removed: boolean;
        fileUrls: string[];
        thumbnailUrl: string | null;
    }>;
    setThumbnail(uuid: string, thumbnailUrl: string | null): Promise<{
        uuid: string;
        id: number;
        start_time: Date;
        end_time: Date | null;
        anon_id: string;
        anon_text_color: string;
        anon_background_color: string;
        title: string;
        description: string;
        status: import("@prisma/client").$Enums.StreamStatus;
        removed: boolean;
        fileUrls: string[];
        thumbnailUrl: string | null;
    }>;
    joinStream(uuid: string, peerId: string): Promise<{
        id: number;
        stream_id: number;
        stage: number;
        peer_id: string;
        parents: string[];
        children: string[];
    }>;
    leaveStream(uuid: string, peerId: string): Promise<boolean>;
    getPositions(uuid: string): Promise<{
        id: number;
        stream_id: number;
        stage: number;
        peer_id: string;
        parents: string[];
        children: string[];
    }[]>;
    private publishHierarchy;
    private recomputeHierarchy;
}
